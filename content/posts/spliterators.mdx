---
title: Spliterators
tags: java
publishedAt: 2025-04-09
---

<Warning>This is a rough, early draft.</Warning>

Like Iterators, Spliterators let you traverse elements of a data source, but they're easier to implement, and can be converted to streams.
This article introduces Spliterators and their advantages over Iterators.

## What is an Iterator?

Let's walk through iterators first since it will help with understanding Spliterators.
An iterator is a built in java interface with methods for traversing through elements of something:

- `boolean hasNext(){:java}` returns `true{:java}` if there are more elements to iterate over
- `T next(){:java}` returns the next element in the iteration
- `void remove(){:java}` removes the last element returned by the iterator

Consider this example that prints the elements of a list:

```java
var numbers = List.of(1, 2, 3);
for (int i = 0; i < numbers.size(); i++) {
    System.out.println(numbers.get(i));
}
```

This works, but what if you want to do the same for a `Set{:java}`? Sets do not have a get by index method like a list, so how do you iterate through its elements? Yes, an iterator!

```java
var numbers = Set.of(1, 2, 3);
for (Iterator<Integer> iterator = numbers.iterator(); iterator.hasNext();) {
    int number = iterator.next();
    System.out.println(number);
}
```

Hooray! You can now traverse arbitrary collections using the same lines of code.
But this comes at a costâ€”the approach is verbose and includes a lot of boilerplate just to iterate over a collection.
The Java language designers must have agreed, because they introduced a simpler alternative: the for-each loop.

```java
var numbers = Set.of(1, 2, 3);
for (int number: numbers) {
    System.out.println(number);
}
```

Yes, the beloved for-each loop is just a nice way of using an iterator.

## How do Spliterators differ from Iterators?

Spliterators and Iterators both allow you traverse through something, but they have some differences. Spliterators:

- Include a few extra methods that allow the Spliterator to be split for parallel operations:
    - `int characteristics(){:java}`
    - `long estimateSize(){:java}`
    - `Spliterator<T> trySplit(){:java}`
- Merge `T next(){:java}` and `boolean hasNext(){:java}` into `boolean tryAdvance(Consumer<? super T> action){:java}`
- Do not have a `E remove(){:java}` method

## How do I make a Spliterator?

Let's make a Spliterator for an array list. Here's our basic class with the fields that we need:

```java
public class ArrayListSpliterator<T> implements Spliterator<T> {
    private final ArrayList<T> list; // the backing ArrayList
    private int current; // the current index, modified on advance/split
    private final int end; // one past the last index

    public ArrayListSpliterator(ArrayList<T> list, int start, int end) {
        this.list = list;
        this.current = start;
        this.end = end;
    }

    public ArrayListSpliterator(ArrayList<T> list) {
        this(list, 0, list.size());
    }
}
```

Now we implement the most important method `boolean tryAdvance(Consumer<? super T> action){:java}`.
If a remaining element exists, the given action will be performed on it, returning true; else returns false.

```java
@Override
public boolean tryAdvance(Consumer<? super T> action) {
    if (current >= end) {
        // We are at the end
        return false;
    }
    // Apply the action to our next element
    action.accept(list.get(current));
    // Increment current for the next call and return true to
    // let the caller know the action was performed
    current += 1;
    return true;
}
```

## How do I create a stream from a Spliterator?

This is the easiest part of the article, let's say you have a Spliterator for integers, you can convert it to a stream with `StreamSupport{:java}`:

```java
Spliterator<Integer> yourSpliterator = List.of(1, 2, 3).spliterator();
Stream<Integer> yourStream = StreamSupport.stream(yourSpliterator, true);
yourStream
        .filter(v -> v % 2 == 1)
        .count();

```
